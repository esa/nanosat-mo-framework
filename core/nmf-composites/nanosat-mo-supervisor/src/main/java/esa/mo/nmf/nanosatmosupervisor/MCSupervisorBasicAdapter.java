/* ----------------------------------------------------------------------------
 * Copyright (C) 2021      European Space Agency
 *                         European Space Operations Centre
 *                         Darmstadt
 *                         Germany
 * ----------------------------------------------------------------------------
 * System                : ESA NanoSat MO Framework
 * ----------------------------------------------------------------------------
 * Licensed under European Space Agency Public License (ESA-PL) Weak Copyleft â€“ v2.4
 * You may not use this file except in compliance with the License.
 *
 * Except as expressly set forth in this License, the Software is provided to
 * You on an "as is" basis and without warranties of any kind, including without
 * limitation merchantability, fitness for a particular purpose, absence of
 * defects or errors, accuracy or non-infringement of intellectual property rights.
 * 
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 * ----------------------------------------------------------------------------
 */
package esa.mo.nmf.nanosatmosupervisor;

import esa.mo.helpertools.connections.ConnectionConsumer;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.bind.JAXBException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;

import org.ccsds.moims.mo.mal.MALException;
import org.ccsds.moims.mo.mal.MALInteractionException;
import org.ccsds.moims.mo.mal.MALStandardError;
import org.ccsds.moims.mo.mal.provider.MALInteraction;
import org.ccsds.moims.mo.mal.structures.UInteger;
import org.ccsds.moims.mo.mal.transport.MALMessageHeader;
import org.ccsds.moims.mo.platform.gps.consumer.GPSAdapter;
import org.xml.sax.SAXException;
import esa.mo.nmf.MCRegistration;
import esa.mo.nmf.MonitorAndControlNMFAdapter;
import esa.mo.nmf.NMFException;
import esa.mo.nmf.annotations.Action;
import esa.mo.nmf.annotations.ActionParameter;
import esa.mo.nmf.annotations.Parameter;
import esa.mo.nmf.nanosatmosupervisor.parameter.OBSWParameterManager;
import esa.mo.sm.impl.util.OSValidator;
import esa.mo.sm.impl.util.ShellCommander;
import org.ccsds.moims.mo.mal.structures.Attribute;
import org.ccsds.moims.mo.mal.structures.Duration;
import org.ccsds.moims.mo.mal.structures.Identifier;
import org.ccsds.moims.mo.mal.structures.UpdateHeaderList;
import org.ccsds.moims.mo.platform.autonomousadcs.consumer.AutonomousADCSAdapter;
import org.ccsds.moims.mo.platform.autonomousadcs.structures.AttitudeModeSunPointing;
import org.ccsds.moims.mo.platform.autonomousadcs.structures.AttitudeTelemetry;
import org.ccsds.moims.mo.platform.autonomousadcs.structures.Quaternion;

/**
 *
 * @author yannick
 */
public class MCSupervisorBasicAdapter extends MonitorAndControlNMFAdapter {

  private static final Logger LOGGER = Logger.getLogger(MCSupervisorBasicAdapter.class.getName());

  private final static String DATE_PATTERN = "dd MMM yyyy HH:mm:ss.SSS";
  private static final String CMD_CURRENT_PARTITION = "mount -l | grep \"on / \" | grep -o 'mmc.*[0-9]p[0-9]'";
  private static final String CMD_LINUX_VERSION = "uname -a";
  private static final String CMD_WINDOWS_VERSION = "systeminfo | findstr Version";

  private final ShellCommander shellCommander = new ShellCommander();
  private NanoSatMOSupervisor nmfSupervisor;
  private final OSValidator osValidator = new OSValidator();

  @Parameter(description = "The version of the operating system.", generationEnabled = false, onGetFunction = "onGetOSVersion", readOnly = true, reportIntervalSeconds = 10)
  public String OSVersion = "";

  @Parameter(description = "The Current partition where the OS is running. Only works for linux", generationEnabled = false, onGetFunction = "onGetOSPartition", readOnly = true, reportIntervalSeconds = 10)
  public String OSPartition = "";
  
  @Parameter(generationEnabled = false, readOnly = true, reportIntervalSeconds = 10)
  public float attitudeQuatA;
  @Parameter(generationEnabled = false, readOnly = true, reportIntervalSeconds = 10)
  public float attitudeQuatB;
  @Parameter(generationEnabled = false, readOnly = true, reportIntervalSeconds = 10)
  public float attitudeQuatC;
  @Parameter(generationEnabled = false, readOnly = true, reportIntervalSeconds = 10)
  public float attitudeQuatD;
  
  private static final Duration ATTITUDE_MONITORING_INTERVAL = new Duration(1.0);
  
  /**
   * Manages the OBSW parameter provisioning
   */
  private OBSWParameterManager obswParameterManager;
  

  public MCSupervisorBasicAdapter() {
  }
  public void setNmfSupervisor(NanoSatMOSupervisor supervisor) {
    nmfSupervisor = supervisor;
  }
  
  @Override
  public void initialRegistrations(MCRegistration registrationObject) {
    super.initialRegistrations(registrationObject);
    
    if(registrationObject == null){
      return;
    }
    
    /* OBSW PARAMETERS PROXIES */
    try {
      obswParameterManager =
          new OBSWParameterManager(getClass().getClassLoader().getResourceAsStream("Datapool.xml"));
      obswParameterManager.registerParametersProxies(registrationObject);
    } catch (ParserConfigurationException | SAXException | IOException | JAXBException | XMLStreamException e) {
      LOGGER.log(Level.SEVERE, "Couldn't register OBSW parameters proxies", e);
    }
  }
  
  @Override
  public Attribute onGetValue(Long parameterID) throws IOException {
    // see if id matches one of the OBSW parameter proxies
    if (obswParameterManager != null) {
      if (obswParameterManager.isOBSWParameterProxy(parameterID)) {
        return obswParameterManager.getValue(parameterID);
      }
    }

    // otherwise it's one of the annotated internal parameters
    return super.onGetValue(parameterID);
  }

  public void startAdcsAttitudeMonitoring()
  {
    try {
      // Subscribe monitorAttitude
      nmfSupervisor.getPlatformServices().getAutonomousADCSService().monitorAttitudeRegister(
          ConnectionConsumer.subscriptionWildcard(),
          new ADCSDataHandler()
      );
      nmfSupervisor.getPlatformServices().getAutonomousADCSService().enableMonitoring(true,
          ATTITUDE_MONITORING_INTERVAL);
    } catch (IOException | MALInteractionException | MALException | NMFException ex) {
      LOGGER.log(Level.SEVERE, "Error when setting up attitude monitoring.", ex);
    }
  }
  
  public class ADCSDataHandler extends AutonomousADCSAdapter
  {
    @Override
    public void monitorAttitudeNotifyReceived(
        final MALMessageHeader msgHeader,
        final Identifier lIdentifier, final UpdateHeaderList lUpdateHeaderList,
        org.ccsds.moims.mo.platform.autonomousadcs.structures.AttitudeTelemetryList attitudeTelemetryList,
        org.ccsds.moims.mo.platform.autonomousadcs.structures.ActuatorsTelemetryList actuatorsTelemetryList,
        org.ccsds.moims.mo.mal.structures.DurationList controlDurationList,
        org.ccsds.moims.mo.platform.autonomousadcs.structures.AttitudeModeList attitudeModeList,
        final Map qosp)
    {
      LOGGER.log(Level.FINE, "Received monitorAttitude notify");
      for (AttitudeTelemetry attitudeTm : attitudeTelemetryList) {
          Quaternion attitude = attitudeTm.getAttitude();
          attitudeQuatA = attitude.getA();
          attitudeQuatB = attitude.getB();
          attitudeQuatC = attitude.getC();
          attitudeQuatD = attitude.getD();
      }
    }
  }
  
  public void onGetOSVersion() {
    if (osValidator.isWindows()) {
      OSVersion = shellCommander.runCommandAndGetOutputMessage(CMD_WINDOWS_VERSION);
    } else {
      OSVersion = shellCommander.runCommandAndGetOutputMessage(CMD_LINUX_VERSION);
    }
  }

  public void onGetOSPartition() {
    if (osValidator.isUnix()) {
      OSPartition = shellCommander.runCommandAndGetOutputMessage(CMD_CURRENT_PARTITION);
    }
  }

  @Action(name = "NMEA_Sentence", description = "Adds <CR><LF> to a raw NMEA query and forwards it to the GNSS Provider")
  public UInteger nmeaAction(Long actionInstanceObjId, boolean reportProgress, MALInteraction interaction,
      @ActionParameter(name = "arg") String arg) {
    try {
      arg = arg + "\r\n";
      nmfSupervisor.getPlatformServices().getGPSService().getNMEASentence(arg, new GPSConsumerAdapter());
    } catch (MALInteractionException | MALException | IOException | NMFException ex) {
      LOGGER.log(Level.SEVERE, null, ex);
      return new UInteger(1);
    }
    return null;
  }

  @Action(name = "Clock.setTimeUsingDeltaMilliseconds", description = "Sets the clock using a diff between the on-board time and the desired time.")
  public UInteger setTimeUsingDeltaMilliseconds(Long actionInstanceObjId, boolean reportProgress,
      MALInteraction interaction, @ActionParameter(name = "delta", rawUnit = "milliseconds") Long delta) {
    String str = (new SimpleDateFormat(DATE_PATTERN)).format(new Date(System.currentTimeMillis() + delta));

    ShellCommander shell = new ShellCommander();
    shell.runCommand("date -s \"" + str + " UTC\" | hwclock --systohc");
    return null;
  }

  @Action(name = "ADCS.sunpointing")
  public UInteger adcsSunPointing(Long actionInstanceObjId, boolean reportProgress,
      MALInteraction interaction) {
    
    try {
      nmfSupervisor.getPlatformServices().getAutonomousADCSService().setDesiredAttitude(null, new AttitudeModeSunPointing());
    } catch (MALInteractionException | MALException | IOException | NMFException ex) {
      LOGGER.log(Level.SEVERE, null, ex);
      return new UInteger(1);
    }
    return null;
  }

  @Action(name = "ADCS.nadirPointing")
  public UInteger adcsNadirPointing(Long actionInstanceObjId, boolean reportProgress,
      MALInteraction interaction, @ActionParameter(name = "duration") Duration duration) {
    
    try {
      nmfSupervisor.getPlatformServices().getAutonomousADCSService().setDesiredAttitude(duration, new AttitudeModeSunPointing());
    } catch (MALInteractionException | MALException | IOException | NMFException ex) {
      LOGGER.log(Level.SEVERE, null, ex);
      return new UInteger(1);
    }
    return null;
  }

  @Action(name = "ADCS.unsetAttitude")
  public UInteger adcsUnsetAttitude(Long actionInstanceObjId, boolean reportProgress,
      MALInteraction interaction) {
    
    try {
      nmfSupervisor.getPlatformServices().getAutonomousADCSService().setDesiredAttitude(new Duration(0), null);
    } catch (MALInteractionException | MALException | IOException | NMFException ex) {
      LOGGER.log(Level.SEVERE, null, ex);
      return new UInteger(1);
    }
    return null;
  }

  private class GPSConsumerAdapter extends GPSAdapter {

    @Override
    public void getNMEASentenceResponseErrorReceived(MALMessageHeader msgHeader, MALStandardError error,
        Map qosProperties) {
      LOGGER.log(Level.WARNING, "Received response error");
    }

    @Override
    public void getNMEASentenceAckErrorReceived(MALMessageHeader msgHeader, MALStandardError error, Map qosProperties) {
      LOGGER.log(Level.WARNING, "Received ACK error");
    }

    @Override
    public void getNMEASentenceResponseReceived(MALMessageHeader msgHeader, String sentence, Map qosProperties) {
      LOGGER.log(Level.INFO, "Received message " + sentence);
    }

    @Override
    public void getNMEASentenceAckReceived(MALMessageHeader msgHeader, Map qosProperties) {
      LOGGER.log(Level.INFO, "Received ack");
    }

  }

}
